---
source: htmxology-macros/src/route/mod.rs
expression: test_route_derive(input)
---
#[allow(unused)]
mod __test {
    use axum::response::IntoResponse as _;
    impl htmxology::Route for MyRoute {
        fn method(&self) -> http::Method {
            match self {
                Self::Api { route, .. } => route.method(),
            }
        }
    }
    impl std::fmt::Display for MyRoute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::Api { route } => {
                    std::fmt::Write::write_char(f, '/')?;
                    f.write_str("api")?;
                    route.fmt(f)?;
                }
            };
            Ok(())
        }
    }
    impl std::str::FromStr for MyRoute {
        type Err = htmxology::ParseError;
        fn from_str(__s: &str) -> Result<Self, Self::Err> {
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/api(?P<subroute>/.*)$").unwrap());
                let (__path, __query_str): (&str, &str) = match __s.split_once('?') {
                    Some((p, q)) => (p, q),
                    None => (__s, ""),
                };
                if let Some(__captures) = RE.captures(__path) {
                    return Ok({
                        let __subroute_path = __captures
                            .name("subroute")
                            .unwrap()
                            .as_str();
                        let route = ApiRoute::from_str(__subroute_path)?;
                        Self::Api { route }
                    });
                }
            }
            Err(htmxology::ParseError::NoMatchingRoute {
                url: __s.to_string(),
            })
        }
    }
    impl<S: Send + Sync> axum::extract::FromRequest<S> for MyRoute {
        type Rejection = axum::response::Response;
        async fn from_request(
            __req: axum::extract::Request,
            __state: &S,
        ) -> Result<Self, Self::Rejection> {
            use axum::extract::FromRequestParts;
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/api(?P<subroute>/.*)$").unwrap());
                if let Some(__captures) = RE.captures(&__req.uri().path()) {
                    {
                        let __new_path = __captures["subroute"].to_owned();
                        let __req = htmxology::replace_request_path(__req, __new_path);
                        let route = ApiRoute::from_request(__req, __state).await?;
                        return Ok(Self::Api { route });
                    }
                }
            }
            Err(http::StatusCode::NOT_FOUND.into_response())
        }
    }
}
