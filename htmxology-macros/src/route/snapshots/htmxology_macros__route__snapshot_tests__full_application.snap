---
source: htmxology-macros/src/route/mod.rs
expression: test_route_derive(input)
---
#[allow(unused)]
mod __test {
    use axum::response::IntoResponse as _;
    impl htmxology::Route for AppRoute {
        fn method(&self) -> http::Method {
            match self {
                Self::Home => http::Method::GET,
                Self::UserProfile { .. } => http::Method::GET,
                Self::Search { .. } => http::Method::GET,
                Self::DeletePost { .. } => http::Method::DELETE,
                Self::Login { .. } => http::Method::POST,
                Self::Admin { route, .. } => route.method(),
                Self::NotFound(catch_all) => catch_all.method(),
            }
        }
    }
    impl std::fmt::Display for AppRoute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::Home => {
                    std::fmt::Write::write_char(f, '/')?;
                }
                Self::UserProfile { user_id } => {
                    std::fmt::Write::write_char(f, '/')?;
                    f.write_str("users")?;
                    std::fmt::Write::write_char(f, '/')?;
                    user_id.fmt(f)?;
                }
                Self::Search { q } => {
                    std::fmt::Write::write_char(f, '/')?;
                    f.write_str("search")?;
                    let qs = &serde_html_form::to_string(&q)
                        .map_err(|_| std::fmt::Error)?;
                    if !qs.is_empty() {
                        std::fmt::Write::write_char(f, '?')?;
                        f.write_str(&qs)?;
                    }
                }
                Self::DeletePost { post_id } => {
                    std::fmt::Write::write_char(f, '/')?;
                    f.write_str("posts")?;
                    std::fmt::Write::write_char(f, '/')?;
                    post_id.fmt(f)?;
                }
                Self::Login { credentials: _ } => {
                    std::fmt::Write::write_char(f, '/')?;
                    f.write_str("login")?;
                }
                Self::Admin { route } => {
                    std::fmt::Write::write_char(f, '/')?;
                    f.write_str("admin")?;
                    route.fmt(f)?;
                }
                Self::NotFound(catch_all) => catch_all.fmt(f)?,
            };
            Ok(())
        }
    }
    impl std::str::FromStr for AppRoute {
        type Err = htmxology::ParseError;
        fn from_str(__s: &str) -> Result<Self, Self::Err> {
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/users/(?P<user_id>[^/]+)$").unwrap());
                let (__path, __query_str): (&str, &str) = match __s.split_once('?') {
                    Some((p, q)) => (p, q),
                    None => (__s, ""),
                };
                if let Some(__captures) = RE.captures(__path) {
                    return Ok({
                        let user_id: u32 = __captures
                            .name(stringify!(user_id))
                            .ok_or_else(|| htmxology::ParseError::MissingPathParam {
                                param_name: stringify!(user_id).to_string(),
                            })?
                            .as_str()
                            .parse::<u32>()
                            .map_err(|e| htmxology::ParseError::PathParamParse {
                                param_name: stringify!(user_id).to_string(),
                                value: __captures
                                    .name(stringify!(user_id))
                                    .unwrap()
                                    .as_str()
                                    .to_string(),
                                error: e.to_string(),
                            })?;
                        Self::UserProfile { user_id }
                    });
                }
            }
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/search$").unwrap());
                let (__path, __query_str): (&str, &str) = match __s.split_once('?') {
                    Some((p, q)) => (p, q),
                    None => (__s, ""),
                };
                if let Some(__captures) = RE.captures(__path) {
                    return Ok({
                        let q = serde_html_form::from_str::<String>(__query_str)
                            .map_err(|e| htmxology::ParseError::QueryStringParse {
                                error: e.to_string(),
                            })?;
                        Self::Search { q }
                    });
                }
            }
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/admin(?P<subroute>/.*)$").unwrap());
                let (__path, __query_str): (&str, &str) = match __s.split_once('?') {
                    Some((p, q)) => (p, q),
                    None => (__s, ""),
                };
                if let Some(__captures) = RE.captures(__path) {
                    return Ok({
                        let __subroute_path = __captures
                            .name("subroute")
                            .unwrap()
                            .as_str();
                        let route = AdminRoute::from_str(__subroute_path)?;
                        Self::Admin { route }
                    });
                }
            }
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/$").unwrap());
                let (__path, __query_str): (&str, &str) = match __s.split_once('?') {
                    Some((p, q)) => (p, q),
                    None => (__s, ""),
                };
                if let Some(__captures) = RE.captures(__path) {
                    return Ok(Self::Home);
                }
            }
            Ok({
                let catch_all = NotFoundRoute::from_str(__s)?;
                Self::NotFound(catch_all)
            })
        }
    }
    impl<S: Send + Sync> axum::extract::FromRequest<S> for AppRoute {
        type Rejection = axum::response::Response;
        async fn from_request(
            __req: axum::extract::Request,
            __state: &S,
        ) -> Result<Self, Self::Rejection> {
            use axum::extract::FromRequestParts;
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/admin(?P<subroute>/.*)$").unwrap());
                if let Some(__captures) = RE.captures(&__req.uri().path()) {
                    {
                        let __new_path = __captures["subroute"].to_owned();
                        let __req = htmxology::replace_request_path(__req, __new_path);
                        let route = AdminRoute::from_request(__req, __state).await?;
                        return Ok(Self::Admin { route });
                    }
                }
            }
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/users/(?P<user_id>[^/]+)$").unwrap());
                if let Some(__captures) = RE.captures(&__req.uri().path()) {
                    return match __req.method() {
                        &http::Method::GET => {
                            Ok({
                                let user_id = htmxology::decode_path_argument(
                                    stringify!(user_id),
                                    &__captures[stringify!(user_id)],
                                )?;
                                Self::UserProfile { user_id }
                            })
                        }
                        _ => Err(http::StatusCode::METHOD_NOT_ALLOWED.into_response()),
                    };
                }
            }
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/search$").unwrap());
                if let Some(__captures) = RE.captures(&__req.uri().path()) {
                    return match __req.method() {
                        &http::Method::GET => {
                            Ok({
                                let (mut __parts, __body) = __req.into_parts();
                                let axum_extra::extract::Query(q) = axum_extra::extract::Query::from_request_parts(
                                        &mut __parts,
                                        __state,
                                    )
                                    .await
                                    .map_err(|err| err.into_response())?;
                                let __req = http::Request::from_parts(__parts, __body);
                                Self::Search { q }
                            })
                        }
                        _ => Err(http::StatusCode::METHOD_NOT_ALLOWED.into_response()),
                    };
                }
            }
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/posts/(?P<post_id>[^/]+)$").unwrap());
                if let Some(__captures) = RE.captures(&__req.uri().path()) {
                    return match __req.method() {
                        &http::Method::DELETE => {
                            Ok({
                                let post_id = htmxology::decode_path_argument(
                                    stringify!(post_id),
                                    &__captures[stringify!(post_id)],
                                )?;
                                Self::DeletePost { post_id }
                            })
                        }
                        _ => Err(http::StatusCode::METHOD_NOT_ALLOWED.into_response()),
                    };
                }
            }
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/login$").unwrap());
                if let Some(__captures) = RE.captures(&__req.uri().path()) {
                    return match __req.method() {
                        &http::Method::POST => {
                            Ok({
                                let axum_extra::extract::Form(credentials) = axum_extra::extract::Form::from_request(
                                        __req,
                                        __state,
                                    )
                                    .await
                                    .map_err(|err| err.into_response())?;
                                Self::Login { credentials }
                            })
                        }
                        _ => Err(http::StatusCode::METHOD_NOT_ALLOWED.into_response()),
                    };
                }
            }
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/$").unwrap());
                if let Some(__captures) = RE.captures(&__req.uri().path()) {
                    return match __req.method() {
                        &http::Method::GET => Ok(Self::Home),
                        _ => Err(http::StatusCode::METHOD_NOT_ALLOWED.into_response()),
                    };
                }
            }
            {
                <NotFoundRoute as axum::extract::FromRequest<
                    S,
                >>::from_request(__req, __state)
                    .await
                    .map(Self::NotFound)
            }
        }
    }
}
