---
source: htmxology-macros/src/route/mod.rs
expression: test_route_derive(input)
---
#[allow(unused)]
mod __test {
    use axum::response::IntoResponse as _;
    impl htmxology::Route for MyRoute {
        fn method(&self) -> http::Method {
            match self {
                Self::UserPosts { .. } => http::Method::GET,
            }
        }
    }
    impl std::fmt::Display for MyRoute {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::UserPosts { user_id, page } => {
                    std::fmt::Write::write_char(f, '/')?;
                    f.write_str("users")?;
                    std::fmt::Write::write_char(f, '/')?;
                    user_id.fmt(f)?;
                    std::fmt::Write::write_char(f, '/')?;
                    f.write_str("posts")?;
                    std::fmt::Write::write_char(f, '?')?;
                    let qs = &serde_urlencoded::to_string(&page)
                        .map_err(|_| std::fmt::Error)?;
                    f.write_str(&qs)?;
                }
            };
            Ok(())
        }
    }
    impl<S: Send + Sync> axum::extract::FromRequest<S> for MyRoute {
        type Rejection = axum::response::Response;
        async fn from_request(
            __req: axum::extract::Request,
            __state: &S,
        ) -> Result<Self, Self::Rejection> {
            use axum::extract::FromRequestParts;
            {
                static RE: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(||
                regex::Regex::new("^/users/(?P<user_id>[^/]+)/posts$").unwrap());
                if let Some(__captures) = RE.captures(&__req.uri().path()) {
                    return match __req.method() {
                        &http::Method::GET => {
                            Ok({
                                let user_id = htmxology::decode_path_argument(
                                    stringify!(user_id),
                                    &__captures[stringify!(user_id)],
                                )?;
                                let (mut __parts, __body) = __req.into_parts();
                                let axum::extract::Query(page) = axum::extract::Query::from_request_parts(
                                        &mut __parts,
                                        __state,
                                    )
                                    .await
                                    .map_err(|err| err.into_response())?;
                                let __req = http::Request::from_parts(__parts, __body);
                                Self::UserPosts { user_id, page }
                            })
                        }
                        _ => Err(http::StatusCode::METHOD_NOT_ALLOWED.into_response()),
                    };
                }
            }
            Err(http::StatusCode::NOT_FOUND.into_response())
        }
    }
}
